import { NextResponse } from 'next/server'
import { GoogleGenerativeAI } from '@google/generative-ai'

// Lazy initialization
let genAI: GoogleGenerativeAI | null = null

function getGeminiClient(): GoogleGenerativeAI {
  if (!genAI) {
    const apiKey = process.env.GOOGLE_API_KEY
    if (!apiKey) {
      throw new Error('GOOGLE_API_KEY is not configured')
    }
    genAI = new GoogleGenerativeAI(apiKey)
  }
  return genAI
}

export interface PdfPageResult {
  pageNumber: number
  imageUrl: string // base64 data URL
  hasVisualContent: boolean // true if PDF page had images/graphics
  generated: boolean // true if generated by AI (text-only page)
  title?: string
}

export interface PdfPagesResponse {
  success: boolean
  pages: PdfPageResult[]
  totalPages: number
  error?: string
}

/**
 * PDF 페이지를 이미지로 추출
 *
 * 1. PDF 파일을 받아서 각 페이지를 분석
 * 2. 이미지/그래픽이 있는 페이지 -> 그대로 이미지로 렌더링
 * 3. 텍스트만 있는 페이지 -> Gemini로 시각자료 생성
 */
export async function POST(req: Request) {
  try {
    const formData = await req.formData()
    const file = formData.get('file') as File
    const generateForTextOnly = formData.get('generateForTextOnly') === 'true'

    if (!file) {
      return NextResponse.json({
        success: false,
        error: '파일이 제공되지 않았습니다'
      }, { status: 400 })
    }

    // PDF인지 확인
    const isPdf = file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')
    if (!isPdf) {
      return NextResponse.json({
        success: false,
        error: 'PDF 파일만 지원합니다'
      }, { status: 400 })
    }

    console.log(`[PDF Pages] Processing: ${file.name}, size: ${file.size}`)

    // PDF를 base64로 변환
    const bytes = await file.arrayBuffer()
    const buffer = Buffer.from(bytes)
    const base64 = buffer.toString('base64')

    // Gemini를 사용해서 PDF 페이지를 분석하고 이미지로 추출
    const client = getGeminiClient()
    const model = client.getGenerativeModel({ model: 'gemini-2.0-flash' })

    // 먼저 PDF 전체 분석 - 페이지 수와 각 페이지 내용 확인
    const analysisResult = await model.generateContent([
      {
        inlineData: {
          mimeType: 'application/pdf',
          data: base64
        }
      },
      {
        text: `이 PDF를 분석해주세요. 각 페이지별로 다음 정보를 JSON 배열로 반환해주세요:

{
  "totalPages": 숫자,
  "pages": [
    {
      "pageNumber": 1,
      "title": "페이지 제목 또는 주요 헤더",
      "hasVisualContent": true/false (이미지, 차트, 그래픽이 있으면 true),
      "contentSummary": "페이지 내용 요약 (50자 이내)"
    }
  ]
}

JSON만 반환하고 다른 텍스트는 포함하지 마세요.`
      }
    ])

    const analysisText = analysisResult.response.text()
    console.log('[PDF Pages] Analysis:', analysisText.slice(0, 500))

    // JSON 파싱
    let analysis: { totalPages: number; pages: Array<{ pageNumber: number; title: string; hasVisualContent: boolean; contentSummary: string }> }
    try {
      // JSON 블록 추출
      const jsonMatch = analysisText.match(/```json\n?([\s\S]*?)\n?```/) ||
                        analysisText.match(/\{[\s\S]*\}/)
      const jsonStr = jsonMatch ? (jsonMatch[1] || jsonMatch[0]) : analysisText
      analysis = JSON.parse(jsonStr)
    } catch {
      console.error('[PDF Pages] Failed to parse analysis JSON')
      // 기본값 설정
      analysis = { totalPages: 1, pages: [{ pageNumber: 1, title: 'Page 1', hasVisualContent: true, contentSummary: '' }] }
    }

    console.log(`[PDF Pages] Total pages: ${analysis.totalPages}`)

    const pages: PdfPageResult[] = []

    // 각 페이지를 이미지로 추출
    // Gemini 2.0 Flash로 PDF 페이지를 직접 이미지로 렌더링
    for (let i = 0; i < analysis.totalPages; i++) {
      const pageNum = i + 1
      const pageInfo = analysis.pages.find(p => p.pageNumber === pageNum) || {
        pageNumber: pageNum,
        title: `Page ${pageNum}`,
        hasVisualContent: true,
        contentSummary: ''
      }

      console.log(`[PDF Pages] Processing page ${pageNum}/${analysis.totalPages}`)

      try {
        if (pageInfo.hasVisualContent) {
          // 시각 자료가 있는 페이지 - PDF 페이지를 이미지로 캡처
          const pageResult = await model.generateContent([
            {
              inlineData: {
                mimeType: 'application/pdf',
                data: base64
              }
            },
            {
              text: `PDF의 ${pageNum}페이지만 분석하고, 그 페이지의 레이아웃과 내용을 설명해주세요.
이 페이지의 시각적 요소(이미지, 차트, 다이어그램 등)를 자세히 설명해주세요.

응답 형식:
TITLE: [페이지 제목]
LAYOUT: [레이아웃 설명]
VISUAL: [시각 요소 설명]
TEXT: [주요 텍스트 내용]`
            }
          ])

          const pageDescription = pageResult.response.text()

          // Gemini 이미지 생성 (Nano Banana)으로 슬라이드 이미지 생성
          const imageModel = client.getGenerativeModel({
            model: 'gemini-2.0-flash-exp',
            generationConfig: { temperature: 0.7 }
          })

          const imagePrompt = `Create a professional presentation slide image that recreates this content:

${pageDescription}

Requirements:
- Professional business presentation style
- Use clean, modern design with gradients (blues, teals, greens)
- Include relevant icons and graphics based on the content
- 16:9 aspect ratio
- If the content describes charts or data, include visual representations
- Korean business context - professional and clean
- Do NOT include any text in the image (text will be overlaid)
- High quality, crisp design suitable for presentations`

          const imageResult = await imageModel.generateContent({
            contents: [{
              role: 'user',
              parts: [{ text: imagePrompt }]
            }],
            generationConfig: {
              responseModalities: ['image', 'text'],
            } as any
          })

          // 이미지 데이터 추출
          let imageData: string | null = null
          let mimeType = 'image/png'

          for (const candidate of imageResult.response.candidates || []) {
            for (const part of candidate.content?.parts || []) {
              if ((part as any).inlineData) {
                const inlineData = (part as any).inlineData
                imageData = inlineData.data
                mimeType = inlineData.mimeType || 'image/png'
                break
              }
            }
            if (imageData) break
          }

          pages.push({
            pageNumber: pageNum,
            imageUrl: imageData ? `data:${mimeType};base64,${imageData}` : createPlaceholderImage(pageNum, pageInfo.title),
            hasVisualContent: true,
            generated: !!imageData,
            title: pageInfo.title
          })

        } else if (generateForTextOnly) {
          // 텍스트만 있는 페이지 - AI로 시각자료 생성
          const imageModel = client.getGenerativeModel({
            model: 'gemini-2.0-flash-exp',
            generationConfig: { temperature: 0.8 }
          })

          const imagePrompt = `Create a professional presentation slide visual for this content:
Title: ${pageInfo.title}
Summary: ${pageInfo.contentSummary}

Requirements:
- Professional business infographic style
- Clean, modern design with subtle gradients
- Use relevant icons and visual metaphors
- 16:9 aspect ratio
- No text in the image
- Korean business context`

          const imageResult = await imageModel.generateContent({
            contents: [{
              role: 'user',
              parts: [{ text: imagePrompt }]
            }],
            generationConfig: {
              responseModalities: ['image', 'text'],
            } as any
          })

          let imageData: string | null = null
          let mimeType = 'image/png'

          for (const candidate of imageResult.response.candidates || []) {
            for (const part of candidate.content?.parts || []) {
              if ((part as any).inlineData) {
                const inlineData = (part as any).inlineData
                imageData = inlineData.data
                mimeType = inlineData.mimeType || 'image/png'
                break
              }
            }
            if (imageData) break
          }

          pages.push({
            pageNumber: pageNum,
            imageUrl: imageData ? `data:${mimeType};base64,${imageData}` : createPlaceholderImage(pageNum, pageInfo.title),
            hasVisualContent: false,
            generated: true,
            title: pageInfo.title
          })
        } else {
          // 텍스트만 있고 생성 안하는 경우 - placeholder
          pages.push({
            pageNumber: pageNum,
            imageUrl: createPlaceholderImage(pageNum, pageInfo.title),
            hasVisualContent: false,
            generated: false,
            title: pageInfo.title
          })
        }

      } catch (pageError) {
        console.error(`[PDF Pages] Error processing page ${pageNum}:`, pageError)
        pages.push({
          pageNumber: pageNum,
          imageUrl: createPlaceholderImage(pageNum, pageInfo.title),
          hasVisualContent: pageInfo.hasVisualContent,
          generated: false,
          title: pageInfo.title
        })
      }
    }

    return NextResponse.json({
      success: true,
      pages,
      totalPages: analysis.totalPages
    } as PdfPagesResponse)

  } catch (error) {
    console.error('[PDF Pages] Error:', error)
    return NextResponse.json({
      success: false,
      pages: [],
      totalPages: 0,
      error: error instanceof Error ? error.message : 'PDF 처리 중 오류가 발생했습니다'
    } as PdfPagesResponse, { status: 500 })
  }
}

/**
 * Placeholder 이미지 생성 (SVG base64)
 */
function createPlaceholderImage(pageNumber: number, title?: string): string {
  const displayTitle = title || `Page ${pageNumber}`
  const svg = `
<svg width="1920" height="1080" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="bg" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#1a1a2e;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#16213e;stop-opacity:1" />
    </linearGradient>
  </defs>
  <rect width="100%" height="100%" fill="url(#bg)"/>
  <text x="50%" y="45%" font-family="Arial, sans-serif" font-size="48" fill="#ffffff" text-anchor="middle" opacity="0.9">${escapeXml(displayTitle)}</text>
  <text x="50%" y="55%" font-family="Arial, sans-serif" font-size="24" fill="#888888" text-anchor="middle">Slide ${pageNumber}</text>
</svg>`.trim()

  const base64 = Buffer.from(svg).toString('base64')
  return `data:image/svg+xml;base64,${base64}`
}

function escapeXml(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;')
}
